- JDK、JRE、JVM的有什么区别？

  JDK包括JRE，是一套开发工具包，比JRE多了如文档和一些常用工具，如有些JRE就没有jstat

  JRE包括JVM，是Java程序运行的基础环境，必须有JRE，Java程序才能运行

  JVM翻译是Java虚拟机，是Java程序运行的核心，提供计算机资源的各种抽象，供Java程序调用。

  

- JVM由哪些部分？

  运行时数据区、类加载子系统、执行引擎、本地库接口等

  

- Java有哪些垃圾回收算法？

  微观上，有标记清除算法、标记压缩算法、复制算法、根搜索算法

  宏观上，有分代算法、分区算法、增量回收算法

  

- 分代的依据是什么？

  对于新生代来说，SUN曾做过统计，大部分的对象都是朝生夕死的对象，存活的只是一小部分。Eden区存活的对象正常情况下不会很多，所以Eden区的比例和Survivor区的比例默认为8:1:1。

  而老年代都是一些存活比较久的对象，GC Roots的引用会很多，垃圾回收的时间会很长，所以为了避免频繁的垃圾回收，老年代的默认会比新生代大很多。

  

- 运行时数据区有哪些部分？各自的作用是什么？

  - 堆区，存储程序创建出来的对象
  - 本地方法栈，native方法运行时的数据区域。
  - 虚拟机栈，非native方法的普通方法的数据区域。
  - 方法区，存储字节码文件、方法信息、常量、静态变量、即时编译器编译后的代码缓存等。
  - PC寄存器，CPU寄存器的模拟，用来存储指向下一条指令的地址，由执行引擎来读取下一条指令。

  

  

- 什么情况下会发生栈溢出？

  开辟的栈帧数量太多，超过了栈的内存大小，默认的线程栈是1M。一般在深层次递归时会发生。

  

- 栈帧里面有哪些内容？

  栈由栈帧组成，栈帧存放有存放局部变量表、操作数栈、方法返回地址、动态链接和一些附加信息。

  - 局部变量表，底层其实是一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量
  - 操作数栈，使用数组实现，保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
  - 动态链接，字节码文件中定义了一个常量池，动态链接就是指向运行时常量池的方法引用。
  - 方法返回地址，存放调用当前方法PC寄存器的值
  - 附加信息，如debug时存放的一些信息

  

- 对象如何晋升到老年代？

  在Survivor区达到一定年龄的对象，和从Eden区存活，但Survivor存放不下的对象会被晋升到老年代。

  

- GC Roots是什么？

  常量、静态属性引用的对象；被同步锁synchronized持有的对象；栈中引用到的局部变量等等

  

- 有哪些常见的垃圾收集器，各有什么优缺点？

  - 两个Serial，单线程，一般用于客户端程序，客户端程序内存占用比较小，线程资源要求也不高。或者作为CMS和G1的后备垃圾回收器。优点是占用资源小，缺点是不能多线程，GC效率不高，并且STW。
  - ParNew，Serial 新生代垃圾回收器的升级版，优点是新生代回收时能多线程。一般与CMS搭配使用。
  - 两个Parallel，都是多线程的垃圾回收器，也是Java8默认、最常用的垃圾回收器。优点是多线程，吞吐量高，可以充分利用CPU资源，并且可以自适应动态对堆内存的比例进行调整。缺点是，全程STW，并且自适应调整时，在某些情况下，会导致Survivor区太小，Eden区存活的对象直接晋升到老年代，引起老年代的堆积。
  - CMS，是首款支持并发的老年代垃圾回收器，优点是在多线程回收的同时，能够和用户线程并行。缺点是和用户线程并行时，用户线程产生的浮动垃圾只能在下一次GC时清除；并且默认的Majar GC的阈值太高，92%，很容易导致并发失败，发生Full GC；CMS的调优参数非常复杂，在Java的版本中，它都不是默认的回收器。
  - G1，是一款基于分代、分区、增量回收算法的垃圾回收器，适用于新生代和老年代。优点是垃圾回收基于region，暂停时间可控，较少出现并发失败；缺点是，每个region要维护对象间的引用关系，这占用了较大的一部分堆内存。

  

- ParNew和Parallel Scavenge有什么区别？

  二者都是复制算法、多线程、STW、作用于新生代的垃圾回收器，Parallel Scavenge不能和CMS搭配，ParNew可以。Parallel侧重于吞吐量，有自适应策略，ParNew没有。

  

- CMS和G1有什么区别？

  CMS只作用于老年代，G1作用于整个堆区。

  CMS在微观上采用标记清除算法和标记压缩算法，产生的内存碎片较多，压缩过程也比较慢。G1采用复制算法，将一个Region存活的对象复制到另一个Region，不会产生内存碎片。

  CMS在宏观上采用增量回收算法和分代算法，其Majar GC的区域是整个老年代，粒度较大，容易发生并发失败。G1则还有分区算法，其Mix GC基于一个个Region，粒度较小，更容易控制暂停时间，较少发生并发失败。

  

- 什么是三色标记？CMS进行垃圾回收有哪些流程？

  三色标记
  
  - 黑色，对象本身机器所有引用都被扫描过
  - 灰色，对象本身被扫描过
  - 白色，没有被垃圾回收器扫描过
  
  CMS垃圾回收过程
  
  - 初始标记，暂停所有用户线程，所有的对象都是白色，将GC Roots能直接关联到的对象，标记为灰色对象。速度较快。
  - 并发标记，遍历所有灰色对象的引用，将其引用对象置为灰色，将原灰色对象置为黑色。速度较慢，但不需要停顿用户线程。
  - 重新标记，修正并发标记阶段，用户线程产生的浮动垃圾。将新产生的GC Root置为黑色，并将其引用的对象置为灰色，将失效的灰色对象置为白色。
  - 并发清理，清除未被标记的白色对象，释放内存空间。
  - 重置线程状态，将GC线程的状态重置。



- G1垃圾回收有哪些流程？

  [链接](https://blog.csdn.net/sushuiyuzhou/article/details/108406097#:~:text=G1%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E4%B8%80%3A,%E5%B9%B4%E8%BD%BB%E4%BB%A3GC%20JVM%E5%90%AF%E5%8A%A8%E6%97%B6%2CG1%E5%85%88%E5%87%86%E5%A4%87%E5%A5%BDEden%E5%8C%BA%2C%E7%A8%8B%E5%BA%8F%E5%9C%A8%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%8D%E6%96%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%88%B0Eden%E5%8C%BA%2C%E5%BD%93Eden%E7%A9%BA%E9%97%B4%E8%80%97%E5%B0%BD%E6%97%B6%2CG1%E4%BC%9A%E5%90%AF%E5%8A%A8%E4%B8%80%E6%AC%A1%E5%B9%B4%E8%BD%BB%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%E3%80%82)

  
  
- Miner GC、Majar GC、Mix GC有什么区别？

  Miner GC或者是Young GC，指的是发生在新生代的垃圾回收。

  Majar GC指的是CMS垃圾回收器在老年代达到内存使用阈值后，对老年代进行垃圾回收的过程。

  Mix GC指的是G1垃圾回收器，在达到老年代内存使用阈值后，对整个堆区进行进行垃圾回收的过程，包含YoungGC。

  

- 有哪些类加载器？

  主要有四种类加载器

  - 启动类加载器，Bootstrap ClassLoader，用来加载Java核心的类库，无法被Java程序直接引用

  - 扩展类加载器，Extensions ClassLoader，Java虚拟机会提供一个扩展库的目录，该加载器会在目录中加载类

  - 系统类加载器，System ClassLoader，加载classpath下的Java类，一般Java应用的类都是通过它来加载的。可以通过ClassLoader.getSystemClassLoader()获取。

  - 自定义加载器，通过继承ClassLoader实现。

    

- 类加载的过程是怎样的？

  - 加载阶段，获取该类文件的二进制流，将该二进制流转化成方法去的运行时数据结构，在内存中生成该类的Class对象，最为该类的访问入口。
  - 验证阶段，包括文件格式、元数据、字节码、符号引用等验证。
    - 文件格式验证，验证class文件的规范，版本号是否支持等。
    - 元数据验证，对字节码文件的进行语义分析，是否有父类等。
    - 字节码验证，进行数据流和控制流的分析，如方法中类型是否转换正确等。
    - 符号引用验证，该操作在解析过程中发生，确保解析能正确执行。
  - 准备阶段，为类的静态变量分配内存，并初始化默认值，这些内存都在方法区分配。

  

- 双亲委派是怎么回事？如何打破？

  双亲委派主要防止内存中出现多份同样的字节码。一个类加载器收到类加载的请求时，它会先将这个请求委派给父类，如果服务无法加载，子加载器才会尝试自己去加载。自定义类加载器除了继承ClassLoader外，还需要重写loadClass()和findClass()方法。

  

- 有哪些常用的JVM参数？

  -Xmx，-Xms，-XX:+UseG1GC，-XX:+PrintGCDetails

  

- 有哪些常用的工具，各自的作用是什么？

  jstat，查看GC的信息

  jstack，查看线程栈的信息，排查死锁等

  jinfo，查看Java线程的参数

  jps，查看Java线程，及其启动参数

  

- 强软弱虚等引用关系有什么区别？

  - 强引用(StrongReference)：最传统最基础的引用，指代码中普遍存在的引用赋值。即Object obj = new Object()。无论任何情况下，只要强引用的关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
  - 软引用(SoftReference)：在系统将要内存溢出之前，才会把软引用的对象列入回收范围进行二次回收。如果这次回收还没有足够的内存空间，才会抛OOM(并不是内存不足马上抛OOM)。
  - 弱引用(WeakReference)：被弱引用关联的对象只能生存到下一次垃圾回收之前，当垃圾收集器工作时，无论内存空间是否充足，都会回收掉被弱引用关联的对象。
  - 虚引用(PhantomReference)：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的，就是能在对象被回收时收到一个系统通知。

  