- 并发和并行有什么区别？

  从微观上看，并发是指两个线程抢夺一个CPU的时间片，并行是指两个线程同时运行在多核处理器上，不发生争抢。从应用程序上看，并发强调对资源有争抢关系，并发同时运行不影响。

  

- 进程和线程有什么区别？

  进程是操作系统的调度单位，如操作系统中的进程管理。线程是CPU的调度单位，如四核八线程。

  进程和线程是包含关系，进程可以包含线程，线程不能包含进程，也不能独立运行。

  进程之间内存隔离，线程则使用进程开辟的内存空间。

  

- 什么是上下文切换？

  线程挂起或者睡眠时，为了提高CPU的利用率，会将当前线程的执行状态进行保存，节约出CPU给其它进程，当线程就绪时，CPU从保存的任务中恢复线程的执行状态

  

- 如何查看上下文切换的频率？

  vmstat

  

- 守护线程和用户线程有什么区别？

  用户线程运行在前台，执行具体的任务，如Main线程，手动创建的线程等。守护线程运行在后台，为其它前台线程提供服务，如垃圾回收线程。

  

- 怎么看线程的CPU和内存的使用率？

  top、k8s、grafana

  

- 死锁与活锁的区别，死锁与饥饿的区别？

  - 死锁，例如两个线程互相持有了对方需要的资源，而无法继续执行产生的永久性阻塞

  - 活锁，线程没有被阻塞，只是因为某些条件不满足，导致一直在执行->失败->执行
  - 饥饿，线程获得的资源不足，无法执行

  

- 如何避免死锁？

  避免一个线程获得多个锁，避免一个线程在一个锁内获取多个资源，使用定时锁，trylock(timeout)

  

- 并发编程的三要素是什么？

  - 原子性，一个操作不能被细分，如i=1
  - 可见性，一个线程对共享变量的修改，其它线程能马上看到
  - 有序性，程序按照代码的先后顺序执行

  

- Java有哪几种方式创建线程？

  继承Thread类、实现Runnalbe接口、Callable接口、匿名内部类

  

- Runnable和Callable接口有什么区别？

  Callable接口的call方法有返回值，可以配合Future和FutureTask来获取异步执行的结果

  Runnalbe接口的run方法无法捕获异常，Callable接口允许抛出异常。

  

- run()和start()有什么区别？

  start()用来启动线程，只能调用一次，而run()用于执行代码，可以重复调用。直接调用run()无法获得多线程效果。

  

- interrupt()、destroy()、stop()有什么区别？

  interrupt()会发出一个信号量，通知线程正常结束，如线程阻塞则清除阻塞以结束。stop()则直接关闭线程，若持有锁则不会释放。

  

- sleep()方法和 yield()方法有什么区别？

  sleep睡眠时，让出的CPU资源给其它线程运行，不考虑线程的优先级。yield则会让给优先级更高的线程。

  sleep时，线程转入阻塞状态，yield转入就绪状态

  sleep移植性更好，对操作系统线程优先级调度无要求

  

- notify() 和 notifyAll() 有什么区别？

  notifyAll()调用后，会将等待池中的所有线程转移到锁池，开始锁的争抢，在锁释放后会再次竞争锁。notify()只唤醒一个线程去争抢锁。

  

- interrupted() 和 isInterrupted() 方法的区别？

  interrupted()是静态方法，查看当前线程的中断信号是true还是false，并且清除终端信号。如一个线程处于中断状态，第一次调用返回true，第二次调用则返回false了。isInterrupted()只是查看当前线程的中断信号是true还是false，不会清除中断状态。

  

- FutureTask和Future的作用是什么？

  Future是一个接口，表示一个线程未完成的返回结果，Callable产生结果，Future用于获取结果

  FutureTask是一个异步任务，实现了Runnable和Future接口，封装了获取执行状态、取消任务等操作，可以放入线程池中运行，并异步返回执行结果。

  

- 线程同步以及线程调度有哪些相关的方法？

  

- sleep() 和 wait() 有什么区别？

  sleep()会使线程进入睡眠状态，实际上也是阻塞状态。而wait()在进入睡眠状态时，还会释放所持有的对象锁

  

- 为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？

  从结果上看，Java想让所有对象都能成为锁，因为Thread类没有可用线程对象使用的锁，即使在线程内部定义了锁，也不好明确锁的种类、数量等，如一个线程可能持有多个锁。

  但是对于大部分对象来说，这些方法实际上根本不会用到，可以设计得更优雅一些。

  

- 为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？

  锁对象需要被同步监视器监控，只有在synchronized修饰的代码才会被同步监视器监控



- 什么是线程同步和线程互斥，有哪几种实现方式？

  

- 在监视器(Monitor)内部，是如何做线程同步的？

  监视器和锁是一起使用的，每一个监视器都和对象引用相关联，监视器会监视一块同步代码块，确保一次只能有一个线程执行同步代码块。

  

- 什么叫线程安全？servlet 是线程安全吗?

  线程安全是指在多线程环境下，能够正确的共享资源，程序能够正常执行。

  servlet是单实例多线程的，普通的共享变量无法保证线程安全。strusts2是多实例多线程的，所以是线程安全的。springboot则任然沿用servlet单实例多线程的模式，除了request、response对象之外，其它线程不安全。

  

- 如何保证多线程的运行安全？

  加锁、同步代码块、线程本地变量，原子引用

  

- Java 线程数过多会造成什么异常？

  用于上下文切换的时间会比较多，浪费CPU资源。占用操作系统的文件描述符。

  

- Java线程的内存模型是怎样的？

  线程之间的共享变量存储在主内存中，在每个线程内部还有私有的内存空间。当线程读取共享变量是，会先从主内存中读取到自己的私有内存中，更新完再回写到主内存中。

  

- 什么是重排序？有哪几个过程？

  编译型的语言，程序在运行时，编译器等可能会无依赖关系的代码重新排序，称之为重排序。

  源代码->编译器优化重排序->指令集重排序->内存系统重排序->最终执行的指令序列

  

- synchronized关键字底层原理是怎样的？

  jdk 1.6之前的synchronized关键字基于操作系统的mutex互斥锁实现，一个线程获得锁时，其它线程则阻塞。

  新版的synchronized会根据锁对象的对象头中的信息，依次从无锁、偏向锁、轻量级锁、重量级锁进行升级。其它线程在竞争锁资源时，会进行CAS，尝试去替换锁对象头种的线程id。

  

- 锁对象的对象头标记是怎样的？

  01无锁\偏向锁、00轻量级锁、10重量级锁、11GC标志

  

- synchronized可重入的原理是怎样的？

  根据锁对象对象头中的线程Id进行判断，相等则可重入

  

- synchronized锁什么时候降级？

  锁对象所在的内存空间发生垃圾回收时，锁会进行降级

  

- synchronized、volatile、CAS 有什么区别？

  - synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞
  - volatile让共享变量支持可见性和禁止指令重排序优化（不具备原子性）
  - CAS是基于冲突检测的乐观锁

  

- synchronized 和 Lock 有什么区别？ReentrantLock 呢？

  相同点：

  - synchronized和ReentrantLock一样，都是可重入锁


  不同点：

  - synchronized是JVM提供的，而Lock是普通的Java类
  - synchronized可以给代码块、方法、静态方法加锁，Lock只能给代码块加锁
  - synchronized不需要手动释放，Lock需要手动unlock
  - Lock可以知道有没有成功获取锁，synchronized不知道
  - ReentrantLock底层调用的是Unsafe的park()加锁，synchronized则是操作对象头

  

- AQS有了解过吗？

  AbstractQueuedSynchronizer，如ReentrantLock、CountDownLatch中的同步组件，一般还得配合自旋才能进行使用。底层有一个先到先服务的队列对实现公平锁，并通过state变量记录锁的状态，实现可重入。

  
  
- volatile 关键字有什么作用？

  保证可见性和禁止指令重排序

  

- 能创建 volatile 数组吗？

  可以用volatile修饰数组，但作用的范围仅限于数组的地址，而不是数组中具体的值

  

- volatile 变量和 atomic 变量有什么不同？

  volatile变量可以保证可见性，对其变量的操作也可以禁止指令重排序

  atomic的类底层是volatile+cas，以volatile保证可见性和禁止指令重排序，以cas乐观锁尽量保证原子性

  

- volatile 能使得一个非原子操作变成原子操作吗？

  long和double可以，在32位的操作系统中，JVM对64位的long和double操作时，会分成2步，使用volatile修饰时，则会变成原子操作。在64位的系统中，则long和double的读写都是原子操作。



- 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？

  - 乐观锁，很乐观，认为每次读数据的时候其它线程都不会修改，所以不会上锁，但是在写数据时，需要根据版本号等，判断是否更新，如果更新则获取最新的数据进行重试。适用于读取较多的情况。
  - 悲观锁，每次读写数据时都认为其它线程会修改，所以每次都会加上锁。

  

- 读写锁ReentrantReadWriteLock有什么作用？

  用于多读少写的场景，多个线程可以同时进行读取，当有线程进行写入时，其它读线程则不能读。读锁是共享锁，写锁是排它锁，不能同时存在。
  
  
  
- 读写锁ReentrantReadWriteLock允许插队吗？为什么？

  ReentrantReadWriteLock可以是公平锁，也可以是非公平锁。公平锁不允许插队，一个个在队列中等着，读锁可以线程同时读取，写锁会阻塞读线程。
  
  非公平锁允许读锁线程插队，但是为了避免写锁线程饥饿，队列头节点为写锁线程时，不允许读锁线程插队。写锁可以随时插队，但是只有在没有写锁线程时才能插队成功。插队失败则进入等待队列中。
  
  
  
- 读写锁ReentrantReadWriteLock什么情况下会升降级？

  读锁不能升级为写锁，避免多个读锁升级造成死锁。
  
  写锁可以降级为读锁，在不释放写锁的情况下，直接获取读锁，这就是读写锁的降级。
  
  
  
- ThreadLocal是什么?

  线程的本地变量，用以存放成本的私有资源，如Servlet线程的HttpRequest、HttpResponse对象等
  
  
  
- 什么是 CAS？

  compare and swap，比较和交换，一般根据内存地址，期望旧值，期望新值，进行自旋重试。

  

- CAS 的会产生什么问题？

  - ABA问题，一个线程将CAS的期望值从A改成B，再从B改成A。从结果上虽然没有改变，但是如果对版本关系有要求的业务，则可能会有隐患，需要使用带版本号的CAS。
  - 自旋开销，当期望旧值发生改变时，线程会重新获取进行重试，增加CPU开销
  - 单个变量，CAS只能保证一个共享变量的原子操作

  

- 有哪些常用的原子类？

  AtomicInteger、AtomicLong、AtomicReference

  

- 线程池有什么优点？

  复用线程、易于管理、拒绝策略、定期执行等

  

- 什么是ThreadPoolExecutor和Executors？

  Executors是创建线程池的工具类，可以创建固定线程数的线程池，定期执行的线程。

  ThreadPoolExecutor是线程池的JDK自带实现类，可以通过指定核心线程数、最大线程数、队列、拒绝策略、保活时间创建线程池对象。

  

- Executors有哪几种方式创建线程池？

  可以创建固定线程数量的线程池、弹性数量的线程池、单线程的线程池、定周期的线程池。

  

- 线程池都有哪些状态？

  - RUNNING，正常接收任务并处理的状态
  - STOP，不接收新的任务，抛弃所有等待的任务，终端正在执行的任务
  - SHUTDOWN，不接受新任务，但是会等待所有的任务执行结束
  - TIDYING，线程终止，workCount等于0时的状态，在转化为该状态时，会调用teminated()方法
  - TERMINATED，调用teminated()方法后，线程彻底终止，变成该状态



- 线程池中 submit() 和 execute() 方法有什么区别？

  - submit可以接收Runnable和Callable，execute()只能执行Runnable
  - submit可以返回Future对象，execute不能
  - submit可以捕获异常，execute不能

  

- 什么是线程组，为什么在 Java 中不推荐使用？

  ThreadGroup类，可以把一些线程归属到同一个组中。线程组中可以有对象，也可以继续包含线程组。线程池方面管理线程的生命周期、复用线程、减少创建和销毁线程的开销。而线程组则方便了线程的管理。

  线程组线程不安全

  

- 如果你提交任务时，线程池队列已满，这时会发生什么？

  线程池可以自己写个实现，如果是ThreadPoolExecutor的话，有两种情况，队列是无界队列，直接将任务放入队列等待执行，当然队列太长可能会导致Full GC和OOM；如果是有界队列的话，会根据maxPoolSize的大小进行工作线程扩容，扩容后还是满了，那就根据线程池的拒绝策略进行处理。

  

- 线程池有哪几种拒绝策略？

  jdk自带有4种，其它公司也会有自己的实现，如jboss的NewThreadRunsPolicy，新开辟一个线程

  - AbortPolicy，直接抛弃任务，并且抛出异常，如果是线程池中，需要接收异常，还需要使用Future或者FutureTask进行接收
  - DiscardPolicy，丢弃任务，但不抛出异常
  - DiscardOldestPolicy，丢弃最早的
  - CallerRunsPolicy，退回调用方线程执行

  

- 如何合理分配线程池大小?

  合理的分配线程池大小，需要根据业务场景+并发压力进行压测调优。一般可以根据任务的类型进行预估，如CPU密集型，可以设置为可用的逻辑核心数。如IO密集型，则可以设置为CPU的倍数。

  

- 并发集合和同步集合有什么区别？

  同步集合基于synchronized，性能较差

  

- 经常使用哪些并发容器？

  ConcurrentHashMap，CopyOnWriteArrayList，BlockingQueue、ConcurrentSkipListSet

  

- ConcurrentHashMap和HashTable\SynchronizedMap 有什么区别？

  SynchronizedMap\HashTable的锁粒度是整个对象，读写效率非常慢。

  ConcurrentHashMap则进行分段加锁，在保证线程安全的同时，效率更高。同时在修改数据时，使用了volatile保证了值得可见性，不会影响数据得读取。

  

- ConcurrentHashMap 的并发度是什么？

  默认的并发度时16，也就是map中数组的长度。写入的数据最终会放在16个数组元素中，形成链表或者红黑树，操作数组索引1中的元素，并不会对数组索引2中的元素产生影响，所以数组长度多长，就有多少个锁。

  

- ConcurrentHashMap 的put()和get()调用流程是怎样的？

  - put()，如果没有初始化，先进行初始化。如果数组索引上还没有值，直接通过CAS无锁写入。如果数组索引上有值，则产生hash冲突，通过加锁的方式写入，追加到链表尾部或者追加到红黑树中。插入成功则调用addCount()，计数并检查是否需要扩容，如果需要扩容，则扩容成原来的2倍。
  - get()，计算hash值，看key落到数组索引的哪个位置上，如果索引上的头元素符合则直接返回对应的value。如果遇到正在扩容，则调用标记正常扩容的节点，找到了就返回，否则则继续向下遍历。



- Collections.synchronized * 是什么？

  把线程不安全的set、list、map转化为同步容器

  

- CopyOnWriteArrayList 是什么?

  一个适用于多读少写的并发容器，底层基于读写分离和写时复制实现

  

- CopyOnWriteArrayList 的缺点?

  写数据时，需要复制一个新数组，消耗双份的内存，在原数组数据量比较大的情况下，会占用比较多的内存。写数据比较多时，拷贝数组的开销将非常巨大。数组未复制完成的情况下，读取数据可能读到旧的数据，不适用于实时读取的场景。

  

- CopyOnWriteArrayList 的设计思想?

  读写分离，写时复制。读数据时，从旧的数组中读取。写数据时，会基于旧数组拷贝一个新数组，新数据往新数组中写入，写入完成后再以新数组替换旧数组的引用。

  

- CountDownLatch、Semaphore、CyclicBarrier有哪些应用场景？

  - CountDownLatch，系统启动时，开辟多个线程进行初始化，等待所有线程执行结束后，才正式对外提供服务。在线程结束时利用的countdown()方法，标识线程已结束。等所有线程都执行完成之后，主线程的wait()方法得以唤醒。
  - Semaphore，消费者使用线程池进行消费，为了避免异步导致线程池传入过多消息，造成线程池队列堆积数据，所以需要对线程池进行限流。在消费数据时，acquire()方法获取线程资源，线程执行完成后release()释放线程资源，完成对线程池的限流。
  - CyclicBarrier，和CountDownLatch类似，但是提供了reset()方法，可以多次使用。

