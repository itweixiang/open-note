- 什么是IO多路复用？

  //todo 

  

- OSI七层网络模型分别是？

  普通的程序开发一般比较关注的是最顶层的应用层，协议有http、ftp、nfs、jdbc、svc（subversion）。

  其次是中间的传输层，基于TCP/UDP协议，开发企业内部的私有协议。

  在这两层之间，还有表示层进行编码转换、数据解析。会话层则为会话实体建立连接，SSL协议也是会话层的。

  传输层往下还有网络层、数据链路层、物理层，这些做软件开发的倒是关注比较少，有哪个软件工程师会自己做水晶头呢？

  

- TCP/IP四层网络模型分别是？

  TCP/IP四层网络模型，将应用层、表示层、会话层合为应用层，将数据链路层、物理层合为数据链路层，传输层还是传输层，网络层还是网络层。

  

- TCP/UDP协议有什么区别？

  UDP：面向无连接，存在丢包，数据包大小限制64k，不安全不可靠，效率高

  TCP：面向连接，建立连接需要经过三次握手，断开连接需要经过四次挥手，连接稳定安全，效率低。HTTP协议底层采用TCP协议。

  

- 为什么要进行三次握手？

  只有一次握手，客户端无法知道服务端是否接收成功，不确定是否已经建立连接，此时发送数据就可能丢，变成UDP连接了。

  只有二次握手，第二次握手时数据发生丢失，那么服务端以为自己已经返回给了客户端，就会一直等待客户端后续的数据，但是客户端也在等待二次握手的报文，才能发送后续数据。导致两方都在等，所以需要最后一次确认，客户端接收到了服务端的响应才能就绪，服务端也得知道客户端就绪，自己才会就绪。

  

- 是否可以四次握手？

  可以，三次握手已经可以建立稳定的连接了，四次握手当然也可以，只是徒增IO次数而已。

  

- 第三次握手中，如果客户端的ACK未送达服务器，会怎样？

  服务端每隔三秒进行重发，重发五次后，还是连不上，就关闭连接。

  客户端在服务端重发，还未CLOSED时，ACK送达服务端，则服务端进入ESTABLISH状态。

  如果服务端已经CLOSED，ACK才送达服务端，则服务端以RST包应答。

  

- 为什么要进行四次挥手？

  只有一次挥手，那么客户端不确定数据是否能送达服务端

  只有两次挥手，服务端可能存在一些数据没有发送完，此时断开连接，将会导致客户端接收到的数据不完整

  只有三次挥手，服务端无法确认客户端是否接收到完整的数据，所以会进行重发

  只有四次挥手，服务端的数据才能发送完，并且客户端接收到的数据是完整的，服务端才不会重发

  

- 如果已经建立了连接，但客户端出现了故障怎么办？

  服务端每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务端就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务端就认为客户端出了故障，接着就关闭连接。 

  

- TCP滑动窗口的作用是什么？

  简单理解为一个发送的缓冲区。发送端在发送数据时，如果每个报文都阻塞接收端响应，效率比较低。发送端在滑动窗口内，加上接收端未响应的数据和未发送的数据，一齐发送给接收端。不用等待接收端响应，也能发送后续的数据。

  

- 什么是Nagle算法？

  

- 什么是MSS？

  

- TCP的初始序列号是什么？

  TCP的每一端都有一个32bit的序列号，用来记录数据的传输情况。

  

- 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？

  因为服务端收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。 

  

- 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？

  客户端没有收到ACK确认，会重新发送FIN请求。

  

- 客户端TIME_WAIT状态的意义是什么？

  第四次挥手时，客户端发给服务端的ACK报文可能丢失，TIME_WAIT就是用来重发报文的。服务端在没有收到ACK时，会不断进行重发FIN报文，客户端在2倍MSL时间内收到了FIN报文，就会向服务端重发ACK，防止服务端不断重发FIN报文。MSL为一个片段在网络中能存活的最大时间，2倍MSL即发送和接收的最大时间。如果在2倍MSL的时间内，客户端都没有收到FIN报文，那么可以推断服务端已经收到了ACK报文，可以关闭连接了。

  

- Socket属于网络的那个层面？

  传输层，Socket属于TCP、UDP协议的概念

  

- Socket通讯的过程是怎样的？

  服务端初始化的Socket对象，绑定并监听端口，accept阻塞等待客户端连接。客户端初始化也Socket对象，配置连接的服务器IP和端口，绑定并监听端口。此时客户端和服务端的连接就成功建立了。

  

- Socket的常用类有哪些？

  TCP的客户端类Socket，TCP的服务端类ServerSocket，UDP的客户端服务端类DatagramSocket，IP和端口类InetAddress

  

- Socket和Http的区别和应用场景？

  Socket作用于传输层，可以提供TCP的稳定的长连接功能，也可以提供UDP高效的无连接功能。比较偏向于底层，可以基于Socket开发自定义的应用层协议，如Http等。

  Http超文本传输协议，基于Socket，常用于进行网页数据的传输，也可以作为文本传输的通用协议。

  

- Http的请求体有哪些内容？

  请求行，包括请求方式、协议版本、URL。响应行就只有协议版本、状态码等。

  请求头，包含MIME类型、Cookie等。

  请求正文，具体的传输报文，可以是普通文本，也可以是json

  

- Http和Https有什么区别？

  https就是http+ssl证书。ssl证书可以提供数据加密、安全通信线路和完整性保护等功能，需要收费。

  http默认端口是80，https则是443。

  

- 一次完整的HTTP请求所经历几个步骤?

  第一步，经历三次握手，建立TCP连接

  第二步，客户端向服务端发送请求行、请求头、请求正文

  第三步，客户端向服务端发送空行，表示客户端传输结束

  第四步，服务端根据业务做出响应

  第五步，服务端发送响应行、响应头、响应正文

  第六步，服务端发送空行表示传输结束

  第七步，达到保活时间未传输数据，进行四次挥手，关闭连接

  

- 常用HTTP状态码是怎么分类的，有哪些常见的状态码？

  100-200，请求已接收，正在处理；200-300，请求成功；300-400，需要重定向；400-500，语法错误或请求无法实现；500，服务器异常了。

  301，永久重定向；302，临时重定向；401，请求需认证；403，禁止访问；404，找不到资源；500，服务器异常；503，服务器忙。

  

- Http协议中有那些请求方式？

  GET、POST、PUT保存资源，PATCH保存或者更新资源，DELETE删除资源

  

- GET方法与POST方法的区别？

  GET获取数据，POST发送数据。

  GET请求数据在URL上，安全性较差。POST可以放在请求头和请求正文中，相对安全一丢丢。



- PUT请求和POST的区别是什么？

  PUT请求语义要求支持幂等性，POST语义没有幂等性。

  

- Http各个版本有哪些区别？

  Http1.0，是一种无连接无状态的协议，每次请求都会建立一个TCP连接，处理完成则立即断开连接。

  Http1.1，可以通过keep-alive设置保活时间，在包活时间内可以复用TCP连接。

  Http2.0，则兼容之的协议，并拥有更多的有特性，如多路复用，可以复用同一条TCP连接，传输多个请求。二进制分帧，将数据封装成更小的单位，减少服务器内存的使用和连接的开销。首部压缩，压缩请求头，让传输的数据更少。等等。

  

- TLS和SSL是什么？

  HTTPS指的是TLS和SSL，大部分浏览器都只支持TLS，不支持SSL。但因为SSL名气较大，所以混用了。SSL证书是保存在源服务器上的数据文件，

  

- Https握手（加密）流程是怎样的？

  核心流程是客户端生成第一随机数发送给服务端。服务端生成第二随机数，并将服务端公钥、SSL证书返回给客户端。客户端验证SSL证书的合法性，用公钥将生成的第三随机数，也就是预主密钥进行加密，并返回给服务端。服务端用私钥进行解密，得到预主密钥。客户端和服务端，通过第一随机数、第二随机数、预主密钥，计算出会话密钥，后面的数据传输都用这个会话密钥进行对称加密。

  

  以TLS1.2为例，在建立TCP三次握手后，客户端向服务端发送TLS版本、加密套件和生成的第一随机数。服务端响应客户端TLS版本等，并响应生成第二数据数。服务端还要出示SSL证书，返回客户端公钥。客户端生成第三个随机数，预主密钥，并用服务端返回的公钥进行加密，然后发送给服务端。此时客户端确认TLS协商无误，加密开始。服务端收到加密后的预主密钥用私钥进行解密。客户端和服务端，通过第一随机数、第二随机数、预主密钥，计算出会话密钥，后面的数据传输都用这个会话密钥进行对称加密。

  

  第一步，客户端会向服务端发送TLS版本、支持的加密算法、以及一个第一随机数

  第二步，服务端响应客户端，返回的TLS版本、支持的加密算法、和一个第二随机数

  第三步，服务器出示SSL证书，客户端通过CA机构，确认证书的合法性

  第四步，服务端发送一个server key exchange给客户端，包含服务端公钥

  第五步，服务端发送server hello done，表示服务端发送完成

  第六步，客户端生成第三个随机数（预主密钥）并用公钥进行加密，然后发送到服务端。此时客户端TLS协商没问题，加密开始。

  第七步，服务端收到加密后的预主密钥，用私钥进行解密。

  客户端和服务端，后续都通过第一随机数、第二随机数、预主密钥计算出会话密钥，后面的数据传输只是用这个会话密钥进行对称加密。

  

- 什么是对称加密与非对称加密？

  对称加密，加密和解密时都需要通过同一个秘钥，这种方式最大的问题是，如何将秘钥传输给对方。

  非对称加密，是指使用一对非对称秘钥，即公钥和私钥，公钥可以随意发布，私钥只能自己拥有，一般私钥放在服务器上。数据经过公钥加密，就只能通过私钥解密。数据经过私钥加密，就只能通过公钥解密。

  发送方通过公钥进行加密处理，接收方在接收到后，使用私钥进行解密。但是速度会慢很多。

  

- cookie和session对于Http有什么用？

  cookie是web服务器保存在用户浏览器上的文件，可以包含用户的相关信息。浏览器向服务端发送http请求时，会将cookie作为请求头发送到web服务器。

  session是客户端和服务器交互的过程中，服务器保存的客户端信息。

  cookie最大4K，明文存放在浏览器上，安全性较差。session存储在服务端中，安全性较高。

  

- 什么是ARP协议？

  Address Resolution Protocol ，地址解析服务，ARP请求将IP地址广播出去，并接收返回消息，将IP地址转换为物理地址。

  

- 什么是NAT协议？

  Network Address Translation，网络地址转换，如将我本地的局域网IP，转换成公网IP。用以解决IP4地址日渐枯竭的问题。

  

- 有哪些常见的连接状态？

  ESTABLISHED，一般这个状态最多，因为正常情况下，大多数连接都是已建立的情况

  TIME_WAIT，挥手时，服务端发送剩下的数据，会处于这种状态

  LISTEN，一般只有服务器会有这种状态，服务端有个连接队列，用来存放已经完成握手，但是程序还没有处理的连接

  SYN_RECV，遭受到DDOS攻击时，伪造的客户端与客户端建立连接，但又不完成握手，浪费大量服务器资源
  
  CLOSE_WAIT，客户端频繁建立连接并关闭
  
  

https://www.cnblogs.com/alifpga/p/7675850.html